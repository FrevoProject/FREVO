group FullyMeshedNet;

getOutputDeclaration(floattype,inttype,doubletype,seed,iterations,inputsize,inputnodes,outputsize,nodes,activationbody,activationargument,biases,weights) ::= <<

<floattype> bias[<nodes>]={<biases:{bia|<bia>f}; separator=", ">};

<floattype> weight[<nodes>][<nodes>]={<weights:{wei|{<wei:{we|<we>f}; separator=", ">}}; separator=", ">};

<floattype> output[<outputsize>];

<floattype> activate(<floattype> <activationargument>){
  <activationbody>
}

long long int seed=<seed>LL;

<inttype> next(){
   seed=(seed*25214903917LL+11) & ((1 \<\< 48) - 1);
   return (<inttype>)(seed \>\> 22);
}

<doubletype> nextDouble(){
   return ((((long long int)next() \<\< 27) + next()) / (<doubletype>)(1 \<\< 53));
}

<floattype> rand_range(<floattype> border){
  <floattype> val = (<floattype>)(nextDouble()*2.0*border-border);
  return val;
}

void getStep(<floattype> input[]){
  if (<inputsize>==<inputnodes>){
    <inttype> i;
	<inttype> j;
	<floattype> activation [<nodes>];
	for (i=0; i \< <nodes>; i=i+1){
		activation[i]=0;
	}
    for (i=0; i \< <inputsize>; i=i+1) {
      output[i]=input[i];
    }
	for (i=<inputnodes>; i \< <nodes>; i=i+1) {
      <floattype> sum=0.0f;
	  for (j=0; j \< <nodes>; j=j+1) {
        sum=sum+weight[j][i]*output[j];
      }
	  activation[i]=bias[i]+sum;
    }
	for (i = <inputnodes>; i \< <nodes>; i=i+1) {
      output[i]=activate(activation[i]);
    }
  }

}

void getOutput(<floattype> input[]){
  <inttype> i;
  for (i=0; i \< <outputsize>; i=i+1) {
    output[i]=0;
  }
  for (i=0; i \< <iterations> - 1; i=i+1) {
    getStep(input);
  }
  getStep(input);
}

>>